@page "/cross-game"

<div class="centered-container">
    <h3 class="text-center text-light text-uppercase fw-bold">Jogo da Velha</h3>

    <div class="text-center mb-3">
        <label for="difficulty" class="form-label text-light text-uppercase">Dificuldade:</label>
        <select id="difficulty" @onchange="OnDifficultyChanged" class="form-select custom-select w-75 d-inline-block text-uppercase">
            <option value="Easy">F√°cil</option>
            <option value="Medium">M√©dio</option>
            <option value="Hard">Dif√≠cil</option>
        </select>
    </div>

    <p class="text-center text-light mt-2">Vez de: <span class="text-info">@_currentPlayer</span></p>

    <div class="game-board">
        <div class="row">
            <button class="cell btn btn-dark" @onclick="() => MakeMove(0, 0)">@_board[0, 0]</button>
            <button class="cell btn btn-dark" @onclick="() => MakeMove(0, 1)">@_board[0, 1]</button>
            <button class="cell btn btn-dark" @onclick="() => MakeMove(0, 2)">@_board[0, 2]</button>
        </div>
        <div class="row">
            <button class="cell btn btn-dark" @onclick="() => MakeMove(1, 0)">@_board[1, 0]</button>
            <button class="cell btn btn-dark" @onclick="() => MakeMove(1, 1)">@_board[1, 1]</button>
            <button class="cell btn btn-dark" @onclick="() => MakeMove(1, 2)">@_board[1, 2]</button>
        </div>
        <div class="row">
            <button class="cell btn btn-dark" @onclick="() => MakeMove(2, 0)">@_board[2, 0]</button>
            <button class="cell btn btn-dark" @onclick="() => MakeMove(2, 1)">@_board[2, 1]</button>
            <button class="cell btn btn-dark" @onclick="() => MakeMove(2, 2)">@_board[2, 2]</button>
        </div>
    </div>

    @if (_winner != null)
    {
        <div class="result-overlay">
            <div class="result-message-container">
                <p class="text-center my-2 result-message">
                    @if (_winner == "Empate")
                    {
                        <span class="text-warning bg-dark py-1 px-2">Empate! ü§ù</span>
                    }
                    else if (_winner == "X")
                    {
                        <span class="text-success bg-dark py-1 px-2">Voc√™ venceu! ü•≥</span>
                    }
                    else
                    {
                        <span class="text-danger bg-dark py-1 px-2">Voc√™ perdeu! üò¢</span>
                    }
                </p>
                <div class="text-center mt-3">
                    <button @onclick="ResetGame" class="btn btn-light">Iniciar Nova Partida</button>
                </div>
            </div>
        </div>
    }
    <div class="w-100 text-center my-2">
        <button @onclick="ResetGame" class="btn btn-danger">Reiniciar Jogo</button>
    </div>
</div>

<style>
    .centered-container {
        display: flex;
        flex-direction: column;
        -ms-align-items: center;
        -o-align-items: center;
        -webkit-align-items: center;
        align-items: center;
        max-width: 900px;
        margin: auto;
        padding: 20px;
        background-color: #1c1c1e;
        -ms-border-radius: 15px;
        border-radius: 15px;
    }

    .game-board {
        display: grid;
        gap: 10px;
        -o-justify-content: center;
        -webkit-justify-content: center;
        justify-content: center;
        -ms-align-items: center;
        -o-align-items: center;
        -webkit-align-items: center;
        align-items: center;
        margin-top: 20px;
    }

    .row {
        display: flex;
        gap: 10px;
    }

    .cell {
        width: 75px;
        height: 75px;
        font-size: 24px;
        text-align: center;
        vertical-align: middle;
        border: 2px solid #007bff;
        -ms-border-radius: 10px;
        border-radius: 10px;
        -ms-transition: background-color 0.3s, transform 0.3s;
        -o-transition: background-color 0.3s, transform 0.3s;
        -webkit-transition: background-color 0.3s, transform 0.3s;
        transition: background-color 0.3s, transform 0.3s;
        cursor: pointer;
        color: #fff;
    }

        .cell:hover {
            background-color: #007bff;
            color: #fff;
            -ms-transform: scale(1.1);
            -webkit-transform: scale(1.1);
            transform: scale(1.1);
        }

        .cell:active {
            background-color: #0056b3;
            -ms-transform: scale(0.9);
            -webkit-transform: scale(0.9);
            transform: scale(0.9);
        }

    .text-info {
        font-weight: bold;
        animation: blink 1s infinite;
    }

    @@keyframes blink {
        0%, 100% {
            -ms-opacity: 1;
            opacity: 1;
        }

        50% {
            -ms-opacity: 0.5;
            opacity: 0.5;
        }
    }

    .custom-select {
        max-width: 200px;
        background-color: #343a40;
        color: #fff;
        border: 1px solid #007bff;
        -ms-border-radius: 5px;
        border-radius: 5px;
        -ms-transition: background-color 0.3s;
        -o-transition: background-color 0.3s;
        -webkit-transition: background-color 0.3s;
        transition: background-color 0.3s;
    }

        .custom-select:hover, .custom-select:focus {
            background-color: #007bff;
            color: #fff;
        }

    .result-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        -o-justify-content: center;
        -webkit-justify-content: center;
        justify-content: center;
        -ms-align-items: center;
        -o-align-items: center;
        -webkit-align-items: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.75);
        animation: fadeIn 0.5s;
    }

    .result-message-container {
        display: flex;
        flex-direction: column;
        -ms-align-items: center;
        -o-align-items: center;
        -webkit-align-items: center;
        align-items: center;
        animation: slideUp 0.5s, rotateIn 0.5s;
    }

    .result-message {
        font-size: 24px;
        color: #fff;
        animation: scaleUp 0.5s;
    }

    .btn-light {
        color: #000;
        background-color: #f8f9fa;
        border: 1px solid #ccc;
        -ms-transition: background-color 0.3s;
        -o-transition: background-color 0.3s;
        -webkit-transition: background-color 0.3s;
        transition: background-color 0.3s;
    }

        .btn-light:hover {
            background-color: #e2e6ea;
        }

    @@keyframes fadeIn {
        from {
            -ms-opacity: 0;
            opacity: 0;
        }

        to {
            -ms-opacity: 1;
            opacity: 1;
        }
    }

    @@keyframes scaleUp {
        from {
            -ms-transform: scale(0.5);
            -webkit-transform: scale(0.5);
            transform: scale(0.5);
        }

        to {
            -ms-transform: scale(1);
            -webkit-transform: scale(1);
            transform: scale(1);
        }
    }

    @@keyframes slideUp {
        from {
            -ms-transform: translateY(100%);
            -webkit-transform: translateY(100%);
            transform: translateY(100%);
        }

        to {
            -ms-transform: translateY(0);
            -webkit-transform: translateY(0);
            transform: translateY(0);
        }
    }

    @@keyframes rotateIn {
        from {
            -ms-transform: rotate(0deg);
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
        }

        to {
            -ms-transform: rotate(360deg);
            -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
        }
    }

    @@media (max-width: 600px) {
        .cell {
            width: 50px;
            height: 50px;
            font-size: 18px;
        }

        .game-board {
            gap: 5px;
        }

        .row {
            gap: 5px;
        }

        .custom-select {
            width: 75%;
        }

        .result-message {
            font-size: 18px;
        }

        .result-overlay {
            -o-justify-content: flex-start;
            -webkit-justify-content: flex-start;
            justify-content: flex-start;
            -ms-align-items: flex-start;
            -o-align-items: flex-start;
            -webkit-align-items: flex-start;
            align-items: flex-start;
            padding: 20px;
        }

        .result-message-container {
            position: absolute;
            top: 50%;
            left: 50%;
            -ms-transform: translate(-50%, -50%);
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }
    }
</style>

@code {
    #region Propriedades
    private string[,] _board = new string[3, 3];
    private string _currentPlayer;
    private string _winner = null;
    private string _selectedDifficulty = "Easy";
    private bool _isBoardActive = true;  // Controle de ativa√ß√£o do tabuleiro
    private CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();  // Token de cancelamento para jogada da IA
    #endregion

    protected override void OnInitialized()
    {
        ResetGame();
    }

    private void ResetGame()
    {
        _cancellationTokenSource.Cancel();  // Cancelar a jogada da IA anterior, se houver
        _cancellationTokenSource = new CancellationTokenSource();  // Criar um novo token de cancelamento
        _board = new string[3, 3];
        _winner = null;
        _isBoardActive = true;
        SetStartingPlayer();
    }

    private void SetStartingPlayer()
    {
        var random = new Random();
        switch (_selectedDifficulty)
        {
            case "Easy":
            case "Medium":
                _currentPlayer = random.Next(2) == 0 ? "X" : "O";
                if (_currentPlayer == "O")
                {
                    MakeAIMove();
                }
                break;
            case "Hard":
                _currentPlayer = "O";
                MakeAIMove();
                break;
        }

        // For√ßar a atualiza√ß√£o da interface do usu√°rio
        StateHasChanged();
    }

    private void MakeMove(int row, int col)
    {
        if (!_isBoardActive || row < 0 || row >= 3 || col < 0 || col >= 3 || _board[row, col] != null || _winner != null)
        {
            return; // Indices are out of bounds, cell already taken, game already won, or board inactive
        }

        _board[row, col] = _currentPlayer;
        if (CheckWinner())
        {
            _winner = _currentPlayer;
        }
        else if (IsBoardFull())
        {
            _winner = "Empate";
        }
        else
        {
            _currentPlayer = _currentPlayer == "X" ? "O" : "X";
            if (_currentPlayer == "O")
            {
                MakeAIMove();
            }
        }

        // For√ßar a atualiza√ß√£o da interface do usu√°rio
        StateHasChanged();
    }

    private async void MakeAIMove()
    {
        _isBoardActive = false; // Desativar o tabuleiro durante a jogada da IA

        try
        {
            // Simulate thinking time of 2-3 seconds
            await Task.Delay(new Random().Next(2000, 3000), _cancellationTokenSource.Token);

            switch (_selectedDifficulty)
            {
                case "Easy":
                    MakeRandomMove();
                    break;
                case "Medium":
                    MakeMediumMove();
                    break;
                case "Hard":
                    MakeHardMove();
                    break;
            }
        }
        catch (TaskCanceledException)
        {
            // Ignorar exce√ß√£o se a tarefa for cancelada
        }
        finally
        {
            _isBoardActive = true; // Reativar o tabuleiro ap√≥s a jogada da IA
            StateHasChanged(); // Atualizar a interface do usu√°rio
        }
    }

    private void MakeRandomMove()
    {
        var emptyCells = new List<(int, int)>();
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (_board[i, j] == null)
                {
                    emptyCells.Add((i, j));
                }
            }
        }

        if (emptyCells.Count > 0)
        {
            var random = new Random();
            var move = emptyCells[random.Next(emptyCells.Count)];
            _board[move.Item1, move.Item2] = "O";

            if (CheckWinner())
            {
                _winner = "O";
            }
            else if (IsBoardFull())
            {
                _winner = "Empate";
            }
            else
            {
                _currentPlayer = "X";
            }
        }

        // For√ßar a atualiza√ß√£o da interface do usu√°rio
        StateHasChanged();
    }

    private void MakeMediumMove()
    {
        if (!TryBlockPlayer())
        {
            MakeRandomMove();
        }
    }

    private bool TryBlockPlayer()
    {
        // Check for possible player wins and block them
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (_board[i, j] == null)
                {
                    _board[i, j] = "X";
                    if (CheckWinner())
                    {
                        _board[i, j] = null;
                        _board[i, j] = "O";
                        return true;
                    }
                    _board[i, j] = null;
                }
            }
        }
        return false;
    }

    private void MakeHardMove()
    {
        var bestMove = FindBestMove();
        if (bestMove != (-1, -1))
        {
            _board[bestMove.Item1, bestMove.Item2] = "O";

            if (CheckWinner())
            {
                _winner = "O";
            }
            else if (IsBoardFull())
            {
                _winner = "Empate";
            }
            else
            {
                _currentPlayer = "X";
            }
        }

        // For√ßar a atualiza√ß√£o da interface do usu√°rio
        StateHasChanged();
    }

    private (int, int) FindBestMove()
    {
        int bestScore = int.MinValue;
        (int, int) bestMove = (-1, -1);

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (_board[i, j] == null)
                {
                    _board[i, j] = "O";
                    int score = Minimax(_board, 0, false);
                    _board[i, j] = null;

                    if (score > bestScore)
                    {
                        bestScore = score;
                        bestMove = (i, j);
                    }
                }
            }
        }

        return bestMove;
    }

    private int Minimax(string[,] board, int depth, bool isMaximizing)
    {
        string result = GetWinner();
        if (result != null)
        {
            return result == "O" ? 10 - depth : result == "X" ? depth - 10 : 0;
        }

        if (isMaximizing)
        {
            int bestScore = int.MinValue;
            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    if (board[i, j] == null)
                    {
                        board[i, j] = "O";
                        int score = Minimax(board, depth + 1, false);
                        board[i, j] = null;
                        bestScore = Math.Max(score, bestScore);
                    }
                }
            }
            return bestScore;
        }
        else
        {
            int bestScore = int.MaxValue;
            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    if (board[i, j] == null)
                    {
                        board[i, j] = "X";
                        int score = Minimax(board, depth + 1, true);
                        board[i, j] = null;
                        bestScore = Math.Min(score, bestScore);
                    }
                }
            }
            return bestScore;
        }
    }

    private string GetWinner()
    {
        // Check rows and columns
        for (int i = 0; i < 3; i++)
        {
            if (_board[i, 0] != null && _board[i, 0] == _board[i, 1] && _board[i, 1] == _board[i, 2])
                return _board[i, 0];
            if (_board[0, i] != null && _board[0, i] == _board[1, i] && _board[1, i] == _board[2, i])
                return _board[0, i];
        }

        // Check diagonals
        if (_board[0, 0] != null && _board[0, 0] == _board[1, 1] && _board[1, 1] == _board[2, 2])
            return _board[0, 0];
        if (_board[0, 2] != null && _board[0, 2] == _board[1, 1] && _board[1, 1] == _board[2, 0])
            return _board[0, 2];

        return IsBoardFull() ? "Empate" : null;
    }

    private bool CheckWinner()
    {
        // Check rows and columns
        for (int i = 0; i < 3; i++)
        {
            if (_board[i, 0] != null && _board[i, 0] == _board[i, 1] && _board[i, 1] == _board[i, 2])
                return true;
            if (_board[0, i] != null && _board[0, i] == _board[1, i] && _board[1, i] == _board[2, i])
                return true;
        }

        // Check diagonals
        if (_board[0, 0] != null && _board[0, 0] == _board[1, 1] && _board[1, 1] == _board[2, 2])
            return true;
        if (_board[0, 2] != null && _board[0, 2] == _board[1, 1] && _board[1, 1] == _board[2, 0])
            return true;

        return false;
    }

    private bool IsBoardFull()
    {
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (_board[i, j] == null)
                {
                    return false;
                }
            }
        }
        return true;
    }

    private void OnDifficultyChanged(ChangeEventArgs obj)
    {
        _selectedDifficulty = obj.Value.ToString();
        ResetGame();
    }
}